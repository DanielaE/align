[/
  (c) 2014 Glen Joseph Fernandes
  glenjofe at gmail dot com

  Distributed under the Boost Software
  License, Version 1.0.
  http://boost.org/LICENSE_1_0.txt
]

[library Boost.Align
  [quickbook 1.6]
  [id align]
  [copyright 2014 Glen Fernandes]
  [authors [Fernandes, Glen]]
  [dirname align]
  [license Distributed under the
    [@http://boost.org/LICENSE_1_0.txt Boost Software
      License, Version 1.0].
  ]
]

[section Introduction]

This library provides an alignment function, aligned
allocation and deallocation functions, an aligned
allocator, an aligned allocator adaptor, an aligned
deleter, a type trait to query alignment requirements,
and a function to verify pointer value alignment.

[table The Boost.Align Library
  [ [Component] [Description] ]
  [ [`align`]
    [Pointer alignment function]
  ]
  [ [`aligned_alloc`, `aligned_free`]
    [Aligned allocation and deallocation functions]
  ]
  [ [`aligned_allocator`]
    [Alignment aware allocator] ]
  [ [`aligned_allocator_adaptor`]
    [Alignment aware allocator adaptor]
  ]
  [ [`aligned_delete`]
    [Deleter for constructed objects allocated with
      the alignment function]
  ]
  [ [`alignment_of`]
    [Type trait to query alignment requirement of a
      type at compile time]
  ]
  [ [`is_aligned`]
    [Pointer alignment verification function]
  ]
]

[endsect]

[section Rationale]

[section Dynamic allocation]

C++11 added the ability to specify increased alignment
(over-alignment) for class types. Unfortunately,
`::operator new` allocation functions, `new` expressions,
and the default allocator, `std::allocator`, do not
support dynamic memory allocation of over-aligned data.
This library provides allocation functions, allocators,
allocator adaptors, and deleters, that are are alignment
aware.

[table Boost.Align solutions
  [ [Problem] [Solution] ]
  [ [`::operator new(std::size_t,
      const std::no_throw_t&)`]
    [`aligned_alloc(std::size_t, std::size_t)`]
  ]
  [ [`::operator delete(void*)`]
    [`aligned_free(void*)`]
  ]
  [ [`std::allocator<T>`]
    [`aligned_allocator<T>`]
  ]
  [ [`Allocator`]
    [`aligned_allocator_adaptor<Allocator>`]
  ]
  [ [`std::default_delete<T>`]
    [`aligned_delete`]
  ]
]

[endsect]

[section Alignment functions]

C++11 provided `std::align` in the standard library to
align a pointer value. Unfortunately some C++ standard
library implementations do not support it yet (libstdc++
as far as gcc 4.8.0) and other standard library
implementations implement it incorrectly (dinkumware in
msvc 12.0). This library provides it for those
implementations and also for C++03 compilers where it is
equally useful.

[endsect]

[section Alignment traits]

C++11 provided the `std::alignment_of` trait in the
standard library to query the alignment requirement of a
type. Unfortunately some C++ standard library vendors do
not implement it in an entirely standard conforming
manner, such as for array types (libc++ as far as clang
3.4). This library provides it for those implementations
and also for C++03 compilers where it is equally useful.

[endsect]

[section Alignment testing] 

This library provides a function to test the alignment
of a pointer value. It is generally useful in assertions
to validate that memory is correctly aligned.

[endsect]

[endsect]

[section Tutorial]

[section align]

The alignment function can be used to find the first
address of a given alignment value within a given buffer
of a given size. It adjusts the pointer provided, returns
that value, and decreases space by the amount advanced,
if the alignment succeeds, provided sufficient space in
the buffer. Otherwise it yields a null pointer to
indicate failure due to insufficient space.

``
#include <boost/align/align.hpp>

void use(void* ptr, std::size_t size)
{
  (void)ptr;
  (void)size;
}

int main()
{
  char c[110];
  std::size_t n = sizeof c;
  void* p = c;
  void* q = boost::alignment::align(16, 100, p, n);
  if (q) {
    use(q, 100);
  }
}
``

[endsect]

[section:aligned_alloc aligned_alloc and aligned_free]

Consider these functions alignment enabled versions of
`std::malloc(std::size_t)` and `std::free(void*)` or
`::operator new(std::size_t, const std::no_throw_t&)` and
`::operator delete(void*)`. The aligned allocation
function allocates space with the specified size and
alignment. The aligned deallocation function can then
deallocate this space.

``
#include <boost/align/aligned_alloc.hpp>

void use(void* ptr, std::size_t size)
{
  (void)ptr;
  (void)size;
}

int main()
{
  void* p = boost::alignment::aligned_alloc(16, 100);
  if (p) {
    use(p, 100);
    boost::alignment::aligned_free(p);
  }
}
``

[endsect]

[section aligned_allocator]

Consider this class template a superior version of
the default allocator, `std::allocator`, because it
can be used with types that are over-aligned.

``
#include <boost/align/aligned_allocator.hpp>
#include <vector>

struct alignas(16) type {
  float data[4];
};

void use(type* ptr, std::size_t size)
{
  (void)ptr;
  (void)size;
}

int main()
{
  std::vector<type, boost::alignment::
    aligned_allocator<type> > v(100);
  use(&v[0], v.size());
}
``

The optional template parameter of this class allows
specifying a minimum alignment to use for allocations.
The default minimum alignment is 1.

``
#include <boost/align/aligned_allocator.hpp>
#include <vector>

void use(char* ptr, std::size_t size)
{
  (void)ptr;
  (void)size;
}

int main()
{
  std::vector<char, boost::alignment::
    aligned_allocator<char, 16> > v(100);
  use(&v[0], v.size());
}
``

[endsect]

[section aligned_allocator_adaptor]

This class template can turn any existing allocator
type, C++11 or C++03, stateful or stateless, into one
that supports types which are over-aligned.

``
#include <boost/align/aligned_allocator_adaptor.hpp>
#include <vector>

template<class T, class Allocator>
class utility {
public:
  utility(std::size_t size)
    : v(size) {
  }
private:
  std::vector<T, boost::alignment::
    aligned_allocator_adaptor<Allocator> > v;
};

struct alignas(16) type {
  float data[4];
};

int main()
{
  utility<type, std::allocator<type> > u(100);
  (void)u;
}
``

The optional template parameter of this class allows
specifying a minimum alignment to use for allocations.
The default minimum alignment is 1.

``
#include <boost/align/aligned_allocator_adaptor.hpp>
#include <vector>

template<class T, class Allocator, std::size_t Alignment>
class utility {
public:
  utility(std::size_t size)
    : v(size) {
  }
private:
  std::vector<T, boost::alignment::
    aligned_allocator_adaptor<Allocator, Alignment> > v;
};

int main()
{
  utility<char, std::allocator<char>, 16> u(100);
  (void)u;
}
``

[endsect]

[section aligned_delete]

Consider this class an alignment aware version of the
`std::default_delete` deleter class template. It is a
deleter that destroys the object and then deallocates
space using our aligned deallocation function. It should
be used with constructed objects that were allocated
with our aligned allocation function and is useful with
deleter enabled types like `std::unique_ptr`.

``
#include <boost/align/aligned_delete.hpp>
#include <memory>

struct alignas(16) type {
  float data[4];
};

int main()
{
  void* p = boost::alignment::
    aligned_alloc(alignof(type), sizeof(type));
  if (p) {
    type* q = ::new(p) type();
    std::unique_ptr<type,
      boost::alignment::aligned_delete> u(q);
    (void)u;
  }
}
``

[endsect]

[section alignment_of]

This type trait can be used to query the alignment
requirement of a type at compile time. It is useful
in static assertions to validate type alignment.

``
#include <boost/align/alignment_of.hpp>

template<class T>
class utility {
  static_assert(boost::alignment::
    alignment_of(T) == 16, "");
public:
  utility()
    : object() {
  }
private:
  T object;
};

struct alignas(16) type {
  float data[4];
};

int main()
{
  utility<type> u;
  (void)u;
}
``

[endsect]

[section is_aligned]

This function is used to compare the alignment of a
pointer. It is useful in assertions that validate a
pointer value is aligned on a given boundary.

``
#include <boost/align/is_aligned.hpp>
#include <cassert>

void use(void* ptr, std::size_t size)
{
  assert(boost::alignment::is_aligned(ptr, 16));
  (void)size;
}

int main()
{
  alignas(16) char c[100];
  use(c, sizeof c);
}
``

[endsect]

[endsect]

[section Examples]

[section:aligned_ptr aligned_ptr and make_aligned]

This example presents an alternative to `std::unique_ptr`
that for objects allocated with the aligned allocation
function. It is defined simply by providing an alias
template which uses `std::unique_ptr` with our aligned
deleter in place of the default `std::default_delete`
deleter. It also presents an alternative to
`std::make_unique` for the creation of these aligned
unique pointer objects. It is implemented using our
aligned allocation function.

[section Implementation]

``
#include <boost/align/aligned_delete.hpp>
#include <memory>

template<class T>
using aligned_ptr = std::unique_ptr<T,
  boost::alignment::aligned_delete>;

template<class T, class... Args>
inline aligned_ptr<T> make_aligned(Args&&... args)
{
  auto p = boost::alignment::aligned_alloc(alignof(T),
    sizeof(T));
  if (!p) {
    throw std::bad_alloc();
  }
  try {
    auto q = ::new(p) T(std::forward<Args>(args)...);
    return aligned_ptr<T>(q);
  } catch (...) {
    boost::alignment::aligned_free(p);
    throw;
  }
}
``

[endsect]

[section Usage]

``
struct alignas(16) type {
  float data[4];
};

int main()
{
  auto p = make_aligned<type>();
  p->data[0] = 1.0f;
}
``

[endsect]

[endsect]

[section aligned_vector]

This example presents an alternative to `std::vector`
that can be used with over-aligned types, and allows
specifying a minimum alignment. It is defined simply
by providing an alias template which uses `std::vector`
with our aligned allocator.

[section Implementation]

``
#include <boost/align/aligned_allocator.hpp>
#include <vector>

template<class T, std::size_t Alignment = 1>
using aligned_vector = std::vector<T,
  boost::alignment::aligned_allocator<T, Alignment> >;
``

[endsect]

[section Usage]

``
enum {
  cache_line = 64
};

int main()
{
  aligned_vector<char, cache_line> v(32);
  v[0] = 1;
}
``

[endsect]

[endsect]

[endsect]

[include reference.qbk]

[section Vocabulary]

[section:basic_align \[basic.align\]]

Object types have *alignment requirements* which place
restrictions on the addresses at which an object of that
type may be allocated. An *alignment* is an
implementation-defined integer value representing the
number of bytes between successive addresses at which a
given object can be allocated. An object type imposes an
alignment requirement on every object of that type;
stricter alignment can be requested using the alignment
specifier.

A *fundamental alignment* is represented by an alignment
less than or equal to the greatest alignment supported by
the implementation in all contexts, which is equal to
`alignof(std::max_align_t)`. The alignment required for a
type might be different when it is used as the type of a
complete object and when it is used as the type of a
subobject.

[tip
  ``
  struct B { long double d; };
  struct D : virtual B { char c; };
  ``
  When `D` is the type of a complete object, it will have
  a subobject of type `B`, so it must be aligned
  appropriately for a `long double`. If `D` appears as a
  subobject of another object that also has `B` as a
  virtual base class, the `B` subobject might be part of
  a different subobject, reducing the alignment
  requirementson the `D` subobject. ]

The result of the `alignof` operator reflects
the alignment requirement of the type in the
complete-object case.

An *extended alignment* is represented by an alignment
greater than `alignof(std::max_align_t)`. It is
implementation-defined whether any extended alignments
are supported and the contexts in which they are
supported. A type having an extended alignment
requirement is an *over-aligned type*.

[note Every over-aligned type is or contains a class
  type to which extended alignment applies (possibly
  through a non-static data member).]

Alignments are represented as values of the type
`std::size_t`. Valid alignments include only those values
returned by an `alignof` expression for the fundamental
types plus an additional implementation-defined set of
values, which may be empty. Every alignment value shall
be a non-negative integral power of two.

Alignments have an order from *weaker* to *stronger* or
*stricter* alignments. Stricter alignments have larger
alignment values. An address that satisfies an alignment
requirement also satisfies any weaker valid alignment
requirement.

The alignment requirement of a complete type can be
queried using an `alignof` expression. Furthermore, the
types `char`, `signed char`, and `unsigned char` shall
have the weakest alignment requirement.

[note This enables the character types to be used as the
  underlying type for an aligned memory area.]

Comparing alignments is meaningful and provides the
obvious results:

* Two alignments are equal when their numeric values are
  equal.
* Two alignments are different when their numeric values
  are not equal.
* When an alignment is larger than another it represents
  a stricter alignment.

[note The runtime pointer alignment function can be used
  to obtain an aligned pointer within a buffer; the
  aligned-storage templates in the library can be used to
  obtain aligned storage.]

If a request for a specific extended alignment in a
specific context is not supported by an implementation,
the program is ill-formed. Additionally, a request for
runtime allocation of dynamic storage for which the
requested alignment cannot be honored shall be treated
as an allocation failure.

[endsect]

[endsect]

[section Compatibility]

The following compilers and platforms have been tested.

* clang 3.5 - 3.0, linux
* gcc 4.9 - 4.4, linux
* icc 13.1 - 11.1, linux
* msvc 13.0 - 8.0, windows

Any conforming C++11 or C++03 compiler is supported.

[endsect]

[section Acknowledgments]

Glen Fernandes authored the library and contributed it
to the Boost C++ library collection.

The following developers reviewed the design, code,
examples, tests, and documentation.

* Peter Dimov
* Andrey Semashev
* Bjorn Reese
* Steven Watanabe
* Antony Polukhin
* Lars Viklund
* Michael Spencer
* Paul A. Bristow

Ahmed Charles generously served as review manager for
the formal review of the library.

[endsect]

[section History]

[section Update 1.0]

* Updates to the tutorial and reference documentation.

[endsect]

[section Version 1.0]

* Glen Fernandes implemented the Boost.Align library.

[endsect]

[endsect]
